{"componentChunkName":"component---src-templates-lesson-template-js","path":"/namespaces","webpackCompilationHash":"e981f10f1fbb95b7d132","result":{"data":{"markdownRemark":{"html":"<h2 id=\"namespace\"><a href=\"#namespace\" aria-label=\"namespace permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>namespace</h2>\n<p>While chroot is a pretty straightforward, namespaces and cgroups are a bit more nebulous to understand but no less important. Both of these next two features are for security and resource management.</p>\n<p>Let's say you're running own a big server that's in your home and you're selling space to other people (that you don't know) to run their code on your server. What sort of concerns would you have? Let's say you have Alice and Bob who are running e-commerce services dealing with lots of money. They themselves are good citizens of the servers and minding their own business. But then you have Eve join the server who has other intentions: she wants to steal money, source code, and whatever else she can get her hands on from your other tenants on the server. If just gave all three them root access to server, what's to stop Eve from taking everything? Or what if she just wants to disrupt their businesses, even if she's not stealing anything?</p>\n<p>Your first line of defense is that you could log them into chroot'd environments and limit them to only those. Great! Now they can't see each others' files. Problem solved? Well, no, not quite yet. Despite the fact that she can't see the files, she can still see all the processes going on on the computer. She can kill processes, unmount filesystem and potentially even hijack processes.</p>\n<p>Enter namespaces. Namespaces allow you to hide processes from other processes. If we give each chroot'd environment different sets of namespaces, now Alice, Bob, and Eve can't see each others' processes (they even get different process PIDs, or process IDs, so they can't guess what the others have) and you can't steal or hijack what you can't see!</p>\n<p>There's a lot more depth to namespaces beyond what I've outlined here. The above is describing <em>just</em> the UTS (or UNIX Timesharing) namespace. There are more namespaces as well and this will help these containers stay isloated from each other.</p>\n<h2 id=\"the-problem-with-chroot-alone\"><a href=\"#the-problem-with-chroot-alone\" aria-label=\"the problem with chroot alone permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The problem with chroot alone</h2>\n<p>Now, this isn't secure. The only thing we've protected is the file system, mostly.</p>\n<ol>\n<li>chroot in a terminal into our environment</li>\n<li>In another terminal, run <code class=\"language-text\">docker exec -it docker-host bash</code>. This will get another terminal session #2 for us (I'll refer to the chroot'd environment as #1)</li>\n<li>Run <code class=\"language-text\">tail -f /my-new-root/secret.txt &amp;</code> in #2. This will start an infinitely running process in the background.</li>\n<li>Run <code class=\"language-text\">ps</code> to see the process list in #2 and see the <code class=\"language-text\">tail</code> process running. Copy the PID (process ID) for the tail process.</li>\n<li>In #1, the chroot'd shell, run <code class=\"language-text\">kill &lt;PID you just copied&gt;</code>. This will kill the tail process from inside the <code class=\"language-text\">chroot&#39;d</code> environment. This is a problem because that means chroot isn't enough to isolate someone. We need more barriers. This is just one problem, processes, but it's illustrative that we need more isolation beyond just the file system.</li>\n</ol>\n<h2 id=\"safety-with-namespaces\"><a href=\"#safety-with-namespaces\" aria-label=\"safety with namespaces permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Safety with namespaces</h2>\n<p>So let's create a chroot'd environment now that's isolated using namespaces using a new command: <code class=\"language-text\">unshare</code>. <code class=\"language-text\">unshare</code> creates a new isolated namespace from its parent (so you, the server provider can't spy on Bob nor Alice either) and all other future tenants. Run this:</p>\n<p><strong>NOTE</strong>: This next command downloads about 150MB and takes at least a minute to run.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">exit</span> <span class=\"token comment\"># from our chroot'd environment if you're still running it, if not skip this</span>\n\n<span class=\"token comment\"># install debootstrap</span>\n<span class=\"token function\">apt-get</span> update -y\n<span class=\"token function\">apt-get</span> <span class=\"token function\">install</span> <span class=\"token function\">debootstrap</span> -y\n<span class=\"token function\">debootstrap</span> --variant<span class=\"token operator\">=</span>minbase bionic /better-root\n\n<span class=\"token comment\"># head into the new namespace'd, chroot'd environment</span>\nunshare --mount --uts --ipc --net --pid --fork --user --map-root-user <span class=\"token function\">chroot</span> /better-root <span class=\"token function\">bash</span> <span class=\"token comment\"># this also chroot's for us</span>\n<span class=\"token function\">mount</span> -t proc none /proc <span class=\"token comment\"># process namespace</span>\n<span class=\"token function\">mount</span> -t sysfs none /sys <span class=\"token comment\"># filesystem</span>\n<span class=\"token function\">mount</span> -t tmpfs none /tmp <span class=\"token comment\"># filesystem</span></code></pre></div>\n<p>This will create a new environment that's isolated on the system with its own PIDs, mounts (like storage and volumes), and network stack. Now we can't see any of the processes!</p>\n<p>Now try our previous exercise again.</p>\n<ol>\n<li>Run <code class=\"language-text\">tail -f /my-new-root/secret.txt &amp;</code> from #2 (not the unshare env)</li>\n<li>Run <code class=\"language-text\">ps</code> from #1, grab pid for <code class=\"language-text\">tail</code></li>\n<li>Run <code class=\"language-text\">kill &lt;pid for tail&gt;</code>, see that it doesn't work</li>\n</ol>\n<p>We used namespaces to protect our processes! We could explore the other namespaces but know it's a similar exercise: using namespaces to restrict capabilities of containers to interfering with other containers (both for nefarious purposes and to protect ourselves from ourselves.)</p>","frontmatter":{"path":"/namespaces","title":"Namespaces","order":2.2,"section":"Crafting Containers By Hand","description":"Namespaces is the second feature of the Linux kernel that allow for containers. Namespaces let you hide processes, networks, and other core functionality from sets of processes. Brian shows us how to use namespaces manually."}},"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"order":1,"path":"/intro","title":"Introduction"}}},{"node":{"frontmatter":{"order":2,"path":"/what-are-containers","title":"What Are Containers?"}}},{"node":{"frontmatter":{"order":2.1,"path":"/chroot","title":"chroot"}}},{"node":{"frontmatter":{"order":2.2,"path":"/namespaces","title":"Namespaces"}}},{"node":{"frontmatter":{"order":2.3,"path":"/cgroups","title":"cgroups"}}},{"node":{"frontmatter":{"order":3,"path":"/getting-set-up-with-docker","title":"Getting Set Up with Docker"}}},{"node":{"frontmatter":{"order":3.1,"path":"/docker-images-without-docker","title":"Docker Images without Docker"}}},{"node":{"frontmatter":{"order":3.2,"path":"/docker-images-with-docker","title":"Docker Images with Docker"}}},{"node":{"frontmatter":{"order":3.3,"path":"/nodejs-on-docker","title":"Node.js on Docker"}}},{"node":{"frontmatter":{"order":3.4,"path":"/tags","title":"Tags"}}},{"node":{"frontmatter":{"order":3.5,"path":"/docker-cli","title":"Docker CLI"}}},{"node":{"frontmatter":{"order":4,"path":"/dockerfile","title":"Intro to Dockerfiles"}}},{"node":{"frontmatter":{"order":4.1,"path":"/build-a-nodejs-app","title":"Build a Node.js App"}}},{"node":{"frontmatter":{"order":4.2,"path":"/more-complicated-nodejs-app","title":"A More Complicated Node.js App"}}},{"node":{"frontmatter":{"order":4.4,"path":"/expose","title":"A Note on EXPOSE"}}},{"node":{"frontmatter":{"order":4.5,"path":"/layers","title":"Layers"}}},{"node":{"frontmatter":{"order":5,"path":"/alpine-linux","title":"Alpine Linux"}}},{"node":{"frontmatter":{"order":5.1,"path":"/making-our-own-alpine-nodejs-container","title":"Making Our Own Alpine Node.js Container"}}},{"node":{"frontmatter":{"order":5.2,"path":"/multi-stage-builds","title":"Multi Stage Builds"}}},{"node":{"frontmatter":{"order":5.3,"path":"/static-assets-project","title":"Static Assets Project"}}},{"node":{"frontmatter":{"order":6,"path":"/bind-mounts","title":"Bind Mounts"}}},{"node":{"frontmatter":{"order":6.1,"path":"/volumes","title":"Volumes"}}},{"node":{"frontmatter":{"order":6.2,"path":"/dev-containers","title":"Using Containers for your Dev Environment"}}},{"node":{"frontmatter":{"order":6.3,"path":"/visual-studio-code","title":"Dev Containers with Visual Studio Code"}}},{"node":{"frontmatter":{"order":6.4,"path":"/networking","title":"Networking with Docker"}}},{"node":{"frontmatter":{"order":7,"path":"/docker-compose","title":"Docker Compose"}}},{"node":{"frontmatter":{"order":7.1,"path":"/kubernetes","title":"Kubernetes"}}},{"node":{"frontmatter":{"order":7.2,"path":"/kompose","title":"Kompose"}}},{"node":{"frontmatter":{"order":8,"path":"/buildah","title":"Buildah"}}},{"node":{"frontmatter":{"order":8.1,"path":"/podman","title":"Podman"}}},{"node":{"frontmatter":{"order":13,"path":"/conclusion","title":"Conclusion"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false}}}