{"componentChunkName":"component---src-templates-lesson-template-js","path":"/dockerfile","webpackCompilationHash":"beb5c8eccfad0504ece7","result":{"data":{"markdownRemark":{"html":"<p>So far we've been focusing a lot on running containers and haven't much dug into building them. This is on purpose because most of benefit of containers for developers comes from the running of containers. If you learn one thing, it should be how to run them.</p>\n<p>That said, let's learn to build our own containers. We'll again be using Docker for this though there are other ways to do this. Docker has a special file called a <code class=\"language-text\">Dockerfile</code> which allows you to outline how a container will be built. Each line in a Docker file is a new a directive of how to change your Docker container.</p>\n<p>A <em>big key</em> with Docker container is that they're supposed to be disposable. You should be able to create them and throw them away as many times as necessary. In other words: adopt a mindset of making everything short-lived. There are other, better tools for long-running, custom containers.</p>\n<p>Let's make the most basic Dockerfile ever. Let's make a new folder, maybe on your desktop. Put a file in there called <code class=\"language-text\">Dockerfile</code> (no extension.) In your file, put this.</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token keyword\">FROM</span> node<span class=\"token punctuation\">:</span>latest\n\n<span class=\"token keyword\">CMD</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"node\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"-e\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"console.log(\\\"hi lol\\\")\"</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>The first thing on each line (<code class=\"language-text\">FROM</code> and <code class=\"language-text\">CMD</code> in this case) are called <em>instructions</em>. They don't technically have to be all caps but it's convention to do so so that the file is easier to read. Each one of these instruction incrementally changes the container from the state it was in previously, adding what we call a <em>layer</em>.</p>\n<p>Let's go ahead and build our container. Run (from inside of the directory of where your Dockerfile is)</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">docker build <span class=\"token builtin class-name\">.</span></code></pre></div>\n<p>You should see it out put a bunch of stuff and it'll leave you with the hash of an image. After each instruction, you'll see a hash similar to the ones we've been using for the IDs for the containers. You know why that is? It's because each one of those layers is in-and-of themselves a valid container image! This ends up being important later and we'll discuss it in a bit.</p>\n<p>Our container has two instructions in its Dockerfile, but actually it has many, many more. How? The first instruction, <code class=\"language-text\">FROM node:latest</code> actually means <em>start</em> with the <code class=\"language-text\">node</code> container. That container itself [comes from another Dockerfile][docker-node] which build its own container, which itself <a href=\"https://github.com/docker-library/buildpack-deps\">comes from another Dockerfile</a>, which comes ultimately from the <a href=\"https://hub.docker.com/_/debian/\">Debian</a> image.</p>\n<p>This is something very powerful about Docker: you can use images to build other images and build on the work of others. Instead of having to worry about how to install Debian and all the necessary items to build Node.js from its source, we can just start with a well-put-together image from the community.</p>\n<p>Okay, so we start with <code class=\"language-text\">node:latest</code> and then we add the <code class=\"language-text\">CMD</code> instruction. There will only ever be one of these in effect in a Dockerfile. If you have multiple it'll just take the last one. This is what you want Docker to do when someone runs the container. In our case, we're running <code class=\"language-text\">node -e &quot;console.log(&#39;hi lol&#39;)&quot;</code> from within the container. <code class=\"language-text\">node -e</code>, if you don't know, will run whatever is inside of the quotes with Node.js. In this case, we're logging out <code class=\"language-text\">hi lol</code> to the console.</p>\n<p>You <em>can</em> put <code class=\"language-text\">CMD node -e &quot;console.log(&#39;hi lol&#39;)&quot;</code> as that last line and it'll work but it's not the preferred way of doing it. This won't actually go through bash which itself is simpler and usually safer. I do it this way because the docs strongly encourage you to do it this way.</p>\n<p>So, in essence, our containers nabs a <code class=\"language-text\">node:latest</code> container and then when we have it execute a <code class=\"language-text\">node</code> command when you run it. Let's try it. Grab the hash from your build and run</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">docker run <span class=\"token operator\">&lt;</span>ID<span class=\"token operator\">></span></code></pre></div>\n<p>It's a little inconvenient to always have to refer to it by ID, it'd be easier if it had a name. So let's do that! Try</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">docker build <span class=\"token builtin class-name\">.</span> -t my-node-app\ndocker run my-node-app</code></pre></div>\n<p>Much easier to remember the name rather than a hash. You can see it added <code class=\"language-text\">:latest</code> for you. If you want to version it yourself, you can totally do this:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">docker build <span class=\"token builtin class-name\">.</span> -t my-node-app:1\ndocker run my-node-app:1</code></pre></div>\n<p>Now change your <code class=\"language-text\">Dockerfile</code> so that it logs out <code class=\"language-text\">wat</code> instead of <code class=\"language-text\">hi lol</code>. After you do that.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">docker build <span class=\"token builtin class-name\">.</span> -t my-node-app:2\ndocker run my-node-app:2\ndocker run my-node-app:1</code></pre></div>\n<p>You can version your containers and hold on to older ones, just in case!</p>\n<p>So now let's dig into some more advance things you can do with a Dockerfile. Let's first make our project a real Node.js application. Make a file called <code class=\"language-text\">index.js</code> and put this in there.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> http <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"http\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nhttp\n  <span class=\"token punctuation\">.</span><span class=\"token function\">createServer</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">request<span class=\"token punctuation\">,</span> response</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"request received\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    response<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"omg hi\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"utf-8\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">listen</span><span class=\"token punctuation\">(</span><span class=\"token number\">3000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"server started\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>This more-or-less that most barebones Node.js app you can write. It just responds to HTTP traffic on port 3000. Go ahead and try running it on your local computer (outside of Docker) by running <code class=\"language-text\">node index.js</code>. Hit <a href=\"http://localhost:3000\">localhost:3000</a> to give it a shot.</p>\n<p>Okay, so let's get this running <em>inside</em> Docker now. First thing is we have to copy this file from your local file system into the container. We'll use a new instruction, <code class=\"language-text\">COPY</code>. Modify your Dockerfile to say:</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token keyword\">FROM</span> node<span class=\"token punctuation\">:</span>latest\n\n<span class=\"token keyword\">COPY</span> index.js index.js\n\n<span class=\"token keyword\">CMD</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"node\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"index.js\"</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>This will copy your index.js file from your file system into the Docker file system (the first index.js is the source and the second index.js is the destination of that file inside the container.)</p>\n<p>We then modified the <code class=\"language-text\">CMD</code> to start the server when we finally do run the container. Now run</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">docker build -t my-node-app <span class=\"token builtin class-name\">.</span>\ndocker run my-node-app</code></pre></div>\n<p>Now your Node.js app is running inside of a container managed by Docker! Hooray! But one problem, how do we access it? If you open <a href=\"http://localhost:3000\">locahlost:3000</a> now, it doesn't work! We have to tell Docker to expose the port. So let's do that now. Stop your container from running and run it again like this.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">docker run --publish <span class=\"token number\">3000</span>:3000 my-node-app <span class=\"token comment\"># or you can use -p instead of --publish</span></code></pre></div>\n<p>The <code class=\"language-text\">publish</code> part allows you to forward a port out of a container to the host computer. In this case we're forwarding the port of <code class=\"language-text\">3000</code> (which is what the Node.js server was listening on) to port <code class=\"language-text\">3000</code> on the host machine. The <code class=\"language-text\">3000</code> represents the port on the host machine and the second <code class=\"language-text\">3000</code> represents what port is being used in the container. If you did <code class=\"language-text\">docker run --publish 8000:3000 my-node-app</code>, you'd open <code class=\"language-text\">localhost:8000</code> to see the server (running on port <code class=\"language-text\">3000</code> inside the container).</p>\n<p>Next, let's organize ourselves a bit better. Right now we're putting our app into the root directory of our container and running it as the root user. This both messy and unsafe. If there's an exploit for Node.js that get released, it means that whoever uses that exploit on our Node.js server will doing so as root which means they can do whatever they want. Ungood. So let's fix that. We'll put the directory inside our home directory under a different users.</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token keyword\">FROM</span> node<span class=\"token punctuation\">:</span>latest\n\n<span class=\"token keyword\">USER</span> node\n\n<span class=\"token keyword\">COPY</span> index.js /home/node/code/index.js\n\n<span class=\"token keyword\">CMD</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"node\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"/home/node/code/index.js\"</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>The <code class=\"language-text\">USER</code> instruction let's us switch from being the root user to a different user, one called \"node\" which the <code class=\"language-text\">node:latest</code> image has already made for us. We could make our own user too using bash commands but let's just use the one the node image gave us. (More or less you'd run <code class=\"language-text\">RUN useradd -ms /bin/bash lolcat</code> to add a lolcat user.)</p>\n<p>Notice we're now copying inside of the user's home directory. This is because they'll have proper permissions to interact with those files whereas they may not if we were outside of their home directory. You'll save yourself a lot of permission wrangling if you put it in a home directory.</p>\n<p>It's no big deall that the \"code\" directory doesn't exist, <code class=\"language-text\">COPY</code> will create it.</p>\n<p>Great. Let's make everything a bit more succint by setting a working directory</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token keyword\">FROM</span> node<span class=\"token punctuation\">:</span>latest\n\n<span class=\"token keyword\">USER</span> node\n\n<span class=\"token keyword\">WORKDIR</span> /home/node/code\n\n<span class=\"token keyword\">COPY</span> index.js .\n\n<span class=\"token keyword\">CMD</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"node\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"index.js\"</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p><code class=\"language-text\">WORKDIR</code> works as if you had <code class=\"language-text\">cd</code>'d into that directory, so now all paths are relative to that. And again, if it doesn't exist, it will create it for you.</p>\n<p>Now we just tell <code class=\"language-text\">COPY</code> to copy the file into the same directory. Now we're giving it a directory instead of a file name, it'll just assume we want the same name. You could rename it here if you wanted.</p>\n<h2 id=\"a-more-complicated-app\"><a href=\"#a-more-complicated-app\" aria-label=\"a more complicated app permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>A more complicated app</h2>\n<p>Okay, all looking good so far. Let's make this app go one step further. Let's have it have an npm install step! In the directory where your app is, put this:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// more-or-less the example code from the hapi-pino repo</span>\n<span class=\"token keyword\">const</span> hapi <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"@hapi/hapi\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> server <span class=\"token operator\">=</span> hapi<span class=\"token punctuation\">.</span><span class=\"token function\">server</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    host<span class=\"token punctuation\">:</span> <span class=\"token string\">\"0.0.0.0\"</span><span class=\"token punctuation\">,</span>\n    port<span class=\"token punctuation\">:</span> process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span><span class=\"token constant\">PORT</span> <span class=\"token operator\">||</span> <span class=\"token number\">3000</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  server<span class=\"token punctuation\">.</span><span class=\"token function\">route</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    method<span class=\"token punctuation\">:</span> <span class=\"token string\">\"GET\"</span><span class=\"token punctuation\">,</span>\n    path<span class=\"token punctuation\">:</span> <span class=\"token string\">\"/\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token function\">handler</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> success<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">await</span> server<span class=\"token punctuation\">.</span><span class=\"token function\">register</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    plugin<span class=\"token punctuation\">:</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hapi-pino\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    options<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n      prettyPrint<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">await</span> server<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> server<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">catch</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">err</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  process<span class=\"token punctuation\">.</span><span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>This is a [hapi.js][hapi] server. Hapi is a server-side framework (like Express) for Node.js and my personal favorite. This is going to require that we <code class=\"language-text\">npm install</code> the dependencies. So in your project do the following</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">npm</span> init -y <span class=\"token comment\"># this will create a package.json for you without asking any questions</span>\n<span class=\"token function\">npm</span> <span class=\"token function\">install</span> @hapi/hapi hapi-pino</code></pre></div>\n<p>Now try running <code class=\"language-text\">node index.js</code> to run the Node.js server. You should see it running and logging out info whenever you hit an endpoint. Cool, so now that we have a full featured Node.js app, let's containerize it.</p>\n<p>If we tried to build it and run it right now it'd fail because we didn't <code class=\"language-text\">npm install</code> the dependencies. So now right after the <code class=\"language-text\">COPY</code> we'll add a <code class=\"language-text\">RUN</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token keyword\">FROM</span> node<span class=\"token punctuation\">:</span>latest\n\n<span class=\"token keyword\">USER</span> node\n\n<span class=\"token keyword\">WORKDIR</span> /home/node/code\n\n<span class=\"token keyword\">COPY</span> . .\n\n<span class=\"token keyword\">RUN</span> npm ci\n\n<span class=\"token keyword\">CMD</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"node\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"index.js\"</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>We changed the <code class=\"language-text\">COPY</code> to copy everything in the directory. Right now you probably a <code class=\"language-text\">node_modules</code> but if you're building a container directly from a repo it won't copy the <code class=\"language-text\">node_modules</code> so we have to operate under the assumption that those won't be there. Feel free even to delete them if you want.</p>\n<p>We then added a <code class=\"language-text\">RUN</code> instruction to run a command inside of the container. If you're not familiar with <code class=\"language-text\">npm ci</code> it's very similar to <code class=\"language-text\">npm install</code> with a few key differences: it'll follow the <code class=\"language-text\">package-lock.json</code> exactly (where <code class=\"language-text\">npm install</code> will ignore it and update it if newer patch versions of your dependencies are available) and it'll automatically delete <code class=\"language-text\">node_modules</code> if it exists. <code class=\"language-text\">npm ci</code> is made for situations like this.</p>\n<p>Now if you try to build again, it'll fail with permissions issues. Why? Well, when you have <code class=\"language-text\">WORKDIR</code> create a directory, it does so as root which means that the node user won't have enough permissions to modify that directory. We could either use <code class=\"language-text\">RUN</code> to change the user or we could use <code class=\"language-text\">RUN</code> to make the directory in the first place as node. Let's do the latter.</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token keyword\">FROM</span> node<span class=\"token punctuation\">:</span>latest\n\n<span class=\"token keyword\">USER</span> node\n\n<span class=\"token keyword\">RUN</span> mkdir /home/node/code\n\n<span class=\"token keyword\">WORKDIR</span> /home/node/code\n\n<span class=\"token keyword\">COPY</span> . .\n\n<span class=\"token keyword\">RUN</span> npm ci\n\n<span class=\"token keyword\">CMD</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"node\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"index.js\"</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>Now try building and running your container. It should work now! Yay!</p>\n<p>A side note: make sure you don't bind your app to host <code class=\"language-text\">localhost</code> (like if you put <code class=\"language-text\">localhost</code> instead of <code class=\"language-text\">0.0.0.0</code> in the host in our hapi app.) This will make it so the app is only available <em>inside</em> the container. If you see <code class=\"language-text\">connection reset</code> instead of when you're expecting a response, this a good candidate for what's happening (because this definitely didn't <em>just</em> happen to me ðŸ˜‚.)</p>\n<h2 id=\"a-note-on-expose\"><a href=\"#a-note-on-expose\" aria-label=\"a note on expose permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>A Note on EXPOSE</h2>\n<p>This was a point of confusion for me so I'm going to try to clear it up for you. There is an instruction called <code class=\"language-text\">EXPOSE &lt;port number&gt;</code> that its intended use is to expose ports from within the container to the host machine. However if we don't do the <code class=\"language-text\">-p 3000:3000</code> it still isn't exposed so in reality this instruction doesn't do much. You don't need <code class=\"language-text\">EXPOSE</code>.</p>\n<p>There are two caveats to that. The first is that it could be useful documentation to say that \"I know this Node.js service listens on port 3000 and now anyone who reads this Docekrfile will know that too.\" I would challenge this that I don't think the Dockerfile is the best place for that documentation</p>\n<p>The second caveat is that instead of <code class=\"language-text\">-p 3000:3000</code> you can do <code class=\"language-text\">-P</code>. This will take all of the ports you exposed using <code class=\"language-text\">EXPOSE</code> and will map them to random ports on the host. You can see what ports it chose by using <code class=\"language-text\">docker ps</code>. It'll say something like <code class=\"language-text\">0.0.0.0:32769-&gt;3000/tcp</code> so you can see in this case it chose <code class=\"language-text\">32769</code>. Again, I'd prefer to be deliberate about which ports are being mapped.</p>\n<h2 id=\"layers\"><a href=\"#layers\" aria-label=\"layers permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Layers</h2>\n<p>Go make any change to your Node.js app. Now re-run your build process. Docker is smart enough to see the your <code class=\"language-text\">FROM</code>, <code class=\"language-text\">RUN</code>, and <code class=\"language-text\">WORKDIR</code> instructions haven't changed and wouldn't change if you ran them again so it uses the same containers it cached from the previous but it can see that your <code class=\"language-text\">COPY</code> is different since files changed between last time and this time, so it begins the build process there and re-runs all instructinos after that. Pretty smart, right?</p>\n<p>So which part of container-building takes the longest? <code class=\"language-text\">RUN npm ci</code>. Anything that has to hit the network is going to take the longest without-a-doubt. The shame is that our <code class=\"language-text\">package.json</code> hasn't changed since the previous iteration; we just changed something in our <code class=\"language-text\">index.js</code>. So how we make it so we only re-run our <code class=\"language-text\">npm ci</code> when package.json changes? Break it into two <code class=\"language-text\">COPY</code> instructions!</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token keyword\">FROM</span> node<span class=\"token punctuation\">:</span>latest\n\n<span class=\"token keyword\">USER</span> node\n\n<span class=\"token keyword\">RUN</span> mkdir /home/node/code\n\n<span class=\"token keyword\">WORKDIR</span> /home/node/code\n\n<span class=\"token keyword\">COPY</span> package<span class=\"token punctuation\">-</span>lock.json package.json ./\n\n<span class=\"token keyword\">RUN</span> npm ci\n\n<span class=\"token keyword\">COPY</span> . .\n\n<span class=\"token keyword\">CMD</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"node\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"index.js\"</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>The first <code class=\"language-text\">COPY</code> pulls just the <code class=\"language-text\">package.json</code> and the <code class=\"language-text\">package-lock.json</code> which is just enough to do the <code class=\"language-text\">npm ci</code>. After that we nab the rest of the files. Now if you make changes you avoid doing a full npm install. This is useful and recommended for any dependency installation: apt-get, pip, cargo, gems, etc. as well as any long-running command like building some from source.</p>","frontmatter":{"path":"/dockerfile","title":"The Dockerfile","order":3}},"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"order":1,"path":"/intro","title":"Introduction"}}},{"node":{"frontmatter":{"order":1,"path":"/what-are-containers","title":"What Are Containers?"}}},{"node":{"frontmatter":{"order":2,"path":"/lxc-lxd","title":"lxc & lxd"}}},{"node":{"frontmatter":{"order":2,"path":"/docker","title":"Intro to Docker"}}},{"node":{"frontmatter":{"order":3,"path":"/dockerfile","title":"The Dockerfile"}}},{"node":{"frontmatter":{"order":4,"path":"/going-to-production","title":"Going to Production"}}},{"node":{"frontmatter":{"order":5,"path":"/static-assets-project","title":"Static Assets Project"}}},{"node":{"frontmatter":{"order":6,"path":"/volumes-and-bind-mounts","title":"Volumes and Bind Mounts"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false}}}