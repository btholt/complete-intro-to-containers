{"componentChunkName":"component---src-templates-lesson-template-js","path":"/dev-containers","webpackCompilationHash":"e981f10f1fbb95b7d132","result":{"data":{"markdownRemark":{"html":"<p>So far we've talking about taking an app and using containers to prepare the apps to run. This is an obvious use case for them and one you're going to use a lot. But let's talk about a different use case for them: building development environments for your apps.</p>\n<p>Let's paint a picture. Let's say you got a new job with a company and they're a Ruby shop (if you know Ruby, pretend you don't for a sec.) When you arrive, you're going to be given a very long, likely-out-of-date, complicated README that you're going to have to go look for and struggle to set up the proper version of Ruby, the correct dependencies installed, and that Mercury is in retrograde (just kidding.) Suffice to say, it's a not-fun struggle to get new apps working locally, particularly if it's in a stack that you're not familiar with. Shouldn't there be a better way? There is! (I feel like I'm selling knives on an informercial.)</p>\n<p>Containers! What we can do is define a Dockerfile that sets up all our dependencies so that it's 100% re-createable with zero knowledge of how it works to everyone that approaches it. With bind mounts, we can mount our local code into the container so that we can edit locally and have it propagate into the development container. Let's give it a shot!</p>\n<h2 id=\"hugo\"><a href=\"#hugo\" aria-label=\"hugo permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Hugo</h2>\n<p>I'm not a Go developer. Go is a wonderful language with a rich ecosystem, it's just not what I've previously used. As such, Go is not set up on my computer. But happens if I move onto a new project that uses <a href=\"https://gohugo.io/\">Hugo</a>? Hugo is a great static site generation tool written in Go but one I'm not too familiar with. I could spend a decent amount of time getting everything set up â€¦ or I could use a container! After a quick Internet search, I stumbled across the container <a href=\"https://hub.docker.com/r/jguyomard/hugo-builder/\">hugo-builder</a> which has Hugo all ready to go, I just have to bind in my source files. So let's give it a shot!</p>\n<p><a href=\"https://github.com/btholt/hugo-example\">Your new project is here</a>.</p>\n<p>Let's go from zero to running our new project in dev mode in three commands</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> clone https://github.com/btholt/hugo-example.git\n<span class=\"token builtin class-name\">cd</span> hugo-example/\n<span class=\"token comment\"># you could rewrite the --mount here as -v $PWD:/src</span>\ndocker run --rm -it --mount <span class=\"token assign-left variable\">type</span><span class=\"token operator\">=</span>bind,source<span class=\"token operator\">=</span><span class=\"token string\">\"<span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token builtin class-name\">pwd</span><span class=\"token variable\">)</span></span>\"</span>,target<span class=\"token operator\">=</span>/src -p <span class=\"token number\">1313</span>:1313 -u hugo jguyomard/hugo-builder hugo server -w --bind<span class=\"token operator\">=</span><span class=\"token number\">0.0</span>.0.0</code></pre></div>\n<p>How cool is this? We're zero to developing in Go in three commands! This is a super useful tool for getting developer environments up and running.</p>\n<p>Notice we didn't copy our files in our files. Why? Well, we need our files to live on our host because we want to edit them locally and then run them in the container, right? If they lived in the container, they'd go away once we shut down the container.</p>\n<h2 id=\"aside-on-nodejs-and-native-dependencies\"><a href=\"#aside-on-nodejs-and-native-dependencies\" aria-label=\"aside on nodejs and native dependencies permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Aside on Node.js and Native Dependencies</h2>\n<p>This also works great for Node.js but there would be a problem here, our dependencies (unless you're running Linux as the host and as the container OS.) Whenever you run <code class=\"language-text\">npm install</code> it'll build you dependencies specifically for whatever OS you're on. This is only a problem if you have dependencies that native code in them (like <code class=\"language-text\">node-sass</code> for example) but it's good to know how to handle this.</p>\n<p>Fastest way is to just ignore everything and run the container as-is. Once you have the container running, just <code class=\"language-text\">docker attach</code> to it and run <code class=\"language-text\">npm install</code> yourself inside of the container. A bit manual (and sort of defeating the purpose of containers) but effective.</p>\n<p>The second option which is a bit gross in its own way to add <code class=\"language-text\">npm install &amp;&amp;</code> to the beginning of the <code class=\"language-text\">CMD</code> of your dev container. This will make it so that the node_modules are installed before starting your server. It's a bit of extra overhead on every restart of the app which can be annoying.</p>","frontmatter":{"path":"/dev-containers","title":"Using Containers for your Dev Environment","order":6.2,"section":"Features in Docker","description":null}},"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"order":1,"path":"/intro","title":"Introduction"}}},{"node":{"frontmatter":{"order":2,"path":"/what-are-containers","title":"What Are Containers?"}}},{"node":{"frontmatter":{"order":2.1,"path":"/chroot","title":"chroot"}}},{"node":{"frontmatter":{"order":2.2,"path":"/namespaces","title":"Namespaces"}}},{"node":{"frontmatter":{"order":2.3,"path":"/cgroups","title":"cgroups"}}},{"node":{"frontmatter":{"order":3,"path":"/getting-set-up-with-docker","title":"Getting Set Up with Docker"}}},{"node":{"frontmatter":{"order":3.1,"path":"/docker-images-without-docker","title":"Docker Images without Docker"}}},{"node":{"frontmatter":{"order":3.2,"path":"/docker-images-with-docker","title":"Docker Images with Docker"}}},{"node":{"frontmatter":{"order":3.3,"path":"/nodejs-on-docker","title":"Node.js on Docker"}}},{"node":{"frontmatter":{"order":3.4,"path":"/tags","title":"Tags"}}},{"node":{"frontmatter":{"order":3.5,"path":"/docker-cli","title":"Docker CLI"}}},{"node":{"frontmatter":{"order":4,"path":"/dockerfile","title":"Intro to Dockerfiles"}}},{"node":{"frontmatter":{"order":4.1,"path":"/build-a-nodejs-app","title":"Build a Node.js App"}}},{"node":{"frontmatter":{"order":4.2,"path":"/more-complicated-nodejs-app","title":"A More Complicated Node.js App"}}},{"node":{"frontmatter":{"order":4.4,"path":"/expose","title":"A Note on EXPOSE"}}},{"node":{"frontmatter":{"order":4.5,"path":"/layers","title":"Layers"}}},{"node":{"frontmatter":{"order":5,"path":"/alpine-linux","title":"Alpine Linux"}}},{"node":{"frontmatter":{"order":5.1,"path":"/making-our-own-alpine-nodejs-container","title":"Making Our Own Alpine Node.js Container"}}},{"node":{"frontmatter":{"order":5.2,"path":"/multi-stage-builds","title":"Multi Stage Builds"}}},{"node":{"frontmatter":{"order":5.3,"path":"/static-assets-project","title":"Static Assets Project"}}},{"node":{"frontmatter":{"order":6,"path":"/bind-mounts","title":"Bind Mounts"}}},{"node":{"frontmatter":{"order":6.1,"path":"/volumes","title":"Volumes"}}},{"node":{"frontmatter":{"order":6.2,"path":"/dev-containers","title":"Using Containers for your Dev Environment"}}},{"node":{"frontmatter":{"order":6.3,"path":"/visual-studio-code","title":"Dev Containers with Visual Studio Code"}}},{"node":{"frontmatter":{"order":6.4,"path":"/networking","title":"Networking with Docker"}}},{"node":{"frontmatter":{"order":7,"path":"/docker-compose","title":"Docker Compose"}}},{"node":{"frontmatter":{"order":7.1,"path":"/kubernetes","title":"Kubernetes"}}},{"node":{"frontmatter":{"order":7.2,"path":"/kompose","title":"Kompose"}}},{"node":{"frontmatter":{"order":8,"path":"/buildah","title":"Buildah"}}},{"node":{"frontmatter":{"order":8.1,"path":"/podman","title":"Podman"}}},{"node":{"frontmatter":{"order":13,"path":"/conclusion","title":"Conclusion"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false}}}