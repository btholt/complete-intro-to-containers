{"componentChunkName":"component---src-templates-lesson-template-js","path":"/build-a-nodejs-app","webpackCompilationHash":"85675834e6cbab0a5d00","result":{"data":{"markdownRemark":{"html":"<p>So now let's dig into some more advance things you can do with a Dockerfile. Let's first make our project a real Node.js application. Make a file called <code class=\"language-text\">index.js</code> and put this in there.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> http <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"http\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nhttp\n  <span class=\"token punctuation\">.</span><span class=\"token function\">createServer</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">request<span class=\"token punctuation\">,</span> response</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"request received\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    response<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"omg hi\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"utf-8\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">listen</span><span class=\"token punctuation\">(</span><span class=\"token number\">3000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"server started\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>This more-or-less that most barebones Node.js app you can write. It just responds to HTTP traffic on port 3000. Go ahead and try running it on your local computer (outside of Docker) by running <code class=\"language-text\">node index.js</code>. Hit <a href=\"http://localhost:3000\">localhost:3000</a> to give it a shot.</p>\n<p>Okay, so let's get this running <em>inside</em> Docker now. First thing is we have to copy this file from your local file system into the container. We'll use a new instruction, <code class=\"language-text\">COPY</code>. Modify your Dockerfile to say:</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token keyword\">FROM</span> node<span class=\"token punctuation\">:</span>12<span class=\"token punctuation\">-</span>stretch\n\n<span class=\"token keyword\">COPY</span> index.js index.js\n\n<span class=\"token keyword\">CMD</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"node\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"index.js\"</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>This will copy your index.js file from your file system into the Docker file system (the first index.js is the source and the second index.js is the destination of that file inside the container.)</p>\n<p>We then modified the <code class=\"language-text\">CMD</code> to start the server when we finally do run the container. Now run</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">docker build -t my-node-app <span class=\"token builtin class-name\">.</span>\ndocker run my-node-app</code></pre></div>\n<p>Now your Node.js app is running inside of a container managed by Docker! Hooray! But one problem, how do we access it? If you open <a href=\"http://localhost:3000\">locahlost:3000</a> now, it doesn't work! We have to tell Docker to expose the port. So let's do that now. Stop your container from running and run it again like this.</p>\n<p>Try stopping your server now. Your normal CTRL+C won't work. Node.js itself doesn't handle SIGINT (which is what CTRL+C is) in and of itself. Instead you either have to handle it yourself inside of your Node.js code (preferable for real apps) or you can tell Docker to handle it with the <code class=\"language-text\">--init</code> flag. This uses a package called <a href=\"https://github.com/krallin/tini\">tini</a> to handle shutdown signal for you.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">docker run --init --publish <span class=\"token number\">3000</span>:3000 my-node-app <span class=\"token comment\"># or you can use -p instead of --publish</span></code></pre></div>\n<p>The <code class=\"language-text\">publish</code> part allows you to forward a port out of a container to the host computer. In this case we're forwarding the port of <code class=\"language-text\">3000</code> (which is what the Node.js server was listening on) to port <code class=\"language-text\">3000</code> on the host machine. The <code class=\"language-text\">3000</code> represents the port on the host machine and the second <code class=\"language-text\">3000</code> represents what port is being used in the container. If you did <code class=\"language-text\">docker run --publish 8000:3000 my-node-app</code>, you'd open <code class=\"language-text\">localhost:8000</code> to see the server (running on port <code class=\"language-text\">3000</code> inside the container).</p>\n<p>Next, let's organize ourselves a bit better. Right now we're putting our app into the root directory of our container and running it as the root user. This both messy and unsafe. If there's an exploit for Node.js that get released, it means that whoever uses that exploit on our Node.js server will doing so as root which means they can do whatever they want. Ungood. So let's fix that. We'll put the directory inside our home directory under a different users.</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token keyword\">FROM</span> node<span class=\"token punctuation\">:</span>12<span class=\"token punctuation\">-</span>stretch\n\n<span class=\"token keyword\">USER</span> node\n\n<span class=\"token keyword\">COPY</span> index.js /home/node/code/index.js\n\n<span class=\"token keyword\">CMD</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"node\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"/home/node/code/index.js\"</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>The <code class=\"language-text\">USER</code> instruction let's us switch from being the root user to a different user, one called \"node\" which the <code class=\"language-text\">node:12-stretch</code> image has already made for us. We could make our own user too using bash commands but let's just use the one the node image gave us. (More or less you'd run <code class=\"language-text\">RUN useradd -ms /bin/bash lolcat</code> to add a lolcat user.)</p>\n<p>Notice we're now copying inside of the user's home directory. This is because they'll have proper permissions to interact with those files whereas they may not if we were outside of their home directory. You'll save yourself a lot of permission wrangling if you put it in a home directory. But we'll have to add a flag to the <code class=\"language-text\">COPY</code> command to make sure the user owns those files. We'll do that with <code class=\"language-text\">--chown=node:node</code> where the first <code class=\"language-text\">node</code> is the user and the second <code class=\"language-text\">node</code> is the user group.</p>\n<p>It's no big deal that the \"code\" directory doesn't exist, <code class=\"language-text\">COPY</code> will create it.</p>\n<h3 id=\"a-quick-note-on-copy-vs-add\"><a href=\"#a-quick-note-on-copy-vs-add\" aria-label=\"a quick note on copy vs add permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>A Quick Note on COPY vs ADD</h3>\n<p>The two commands <code class=\"language-text\">COPY</code> and <code class=\"language-text\">ADD</code> do very similar things with a few key differences. <code class=\"language-text\">ADD</code> can also accept, in addition to local files, URLs to download things off the Internet and it will also automatically unzip any tar files it downloads or adds. <code class=\"language-text\">COPY</code> will just copy local files. Use <code class=\"language-text\">COPY</code> unless you need to unzip something or are downloading something.</p>\n<hr>\n<p>Great. Let's make everything a bit more succint by setting a working directory</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token keyword\">FROM</span> node<span class=\"token punctuation\">:</span>12<span class=\"token punctuation\">-</span>stretch\n\n<span class=\"token keyword\">USER</span> node\n\n<span class=\"token keyword\">WORKDIR</span> /home/node/code\n\n<span class=\"token keyword\">COPY</span> <span class=\"token punctuation\">-</span><span class=\"token punctuation\">-</span>chown=node<span class=\"token punctuation\">:</span>node index.js .\n\n<span class=\"token keyword\">CMD</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"node\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"index.js\"</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p><code class=\"language-text\">WORKDIR</code> works as if you had <code class=\"language-text\">cd</code>'d into that directory, so now all paths are relative to that. And again, if it doesn't exist, it will create it for you.</p>\n<p>Now we just tell <code class=\"language-text\">COPY</code> to copy the file into the same directory. Now we're giving it a directory instead of a file name, it'll just assume we want the same name. You could rename it here if you wanted.</p>","frontmatter":{"path":"/build-a-nodejs-app","title":"Build a Node.js App","order":4.1,"section":"The Dockerfile","description":"In order to understand Dockerfiles better, Brian shows how to build a Node.js application inside of a container and how to write a proper Dockerfile for a Node.js app."}},"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"order":1,"path":"/intro","title":"Introduction"}}},{"node":{"frontmatter":{"order":2,"path":"/what-are-containers","title":"What Are Containers?"}}},{"node":{"frontmatter":{"order":2.1,"path":"/chroot","title":"chroot"}}},{"node":{"frontmatter":{"order":2.2,"path":"/namespaces","title":"Namespaces"}}},{"node":{"frontmatter":{"order":2.3,"path":"/cgroups","title":"cgroups"}}},{"node":{"frontmatter":{"order":3,"path":"/getting-set-up-with-docker","title":"Getting Set Up with Docker"}}},{"node":{"frontmatter":{"order":3.1,"path":"/docker-images-without-docker","title":"Docker Images without Docker"}}},{"node":{"frontmatter":{"order":3.2,"path":"/docker-images-with-docker","title":"Docker Images with Docker"}}},{"node":{"frontmatter":{"order":3.3,"path":"/nodejs-on-docker","title":"Node.js on Docker"}}},{"node":{"frontmatter":{"order":3.4,"path":"/tags","title":"Tags"}}},{"node":{"frontmatter":{"order":3.5,"path":"/docker-cli","title":"Docker CLI"}}},{"node":{"frontmatter":{"order":4,"path":"/dockerfile","title":"Intro to Dockerfiles"}}},{"node":{"frontmatter":{"order":4.1,"path":"/build-a-nodejs-app","title":"Build a Node.js App"}}},{"node":{"frontmatter":{"order":4.2,"path":"/more-complicated-nodejs-app","title":"A More Complicated Node.js App"}}},{"node":{"frontmatter":{"order":4.4,"path":"/expose","title":"A Note on EXPOSE"}}},{"node":{"frontmatter":{"order":4.5,"path":"/layers","title":"Layers"}}},{"node":{"frontmatter":{"order":5,"path":"/alpine-linux","title":"Alpine Linux"}}},{"node":{"frontmatter":{"order":5.1,"path":"/making-our-own-alpine-nodejs-container","title":"Making Our Own Alpine Node.js Container"}}},{"node":{"frontmatter":{"order":5.2,"path":"/multi-stage-builds","title":"Multi Stage Builds"}}},{"node":{"frontmatter":{"order":5.3,"path":"/static-assets-project","title":"Static Assets Project"}}},{"node":{"frontmatter":{"order":6,"path":"/bind-mounts","title":"Bind Mounts"}}},{"node":{"frontmatter":{"order":6.1,"path":"/volumes","title":"Volumes"}}},{"node":{"frontmatter":{"order":6.2,"path":"/dev-containers","title":"Using Containers for your Dev Environment"}}},{"node":{"frontmatter":{"order":6.3,"path":"/visual-studio-code","title":"Dev Containers with Visual Studio Code"}}},{"node":{"frontmatter":{"order":6.4,"path":"/networking","title":"Networking with Docker"}}},{"node":{"frontmatter":{"order":7,"path":"/docker-compose","title":"Docker Compose"}}},{"node":{"frontmatter":{"order":7.1,"path":"/kubernetes","title":"Kubernetes"}}},{"node":{"frontmatter":{"order":7.2,"path":"/kompose","title":"Kompose"}}},{"node":{"frontmatter":{"order":8,"path":"/buildah","title":"Buildah"}}},{"node":{"frontmatter":{"order":8.1,"path":"/podman","title":"Podman"}}},{"node":{"frontmatter":{"order":13,"path":"/conclusion","title":"Conclusion"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false}}}